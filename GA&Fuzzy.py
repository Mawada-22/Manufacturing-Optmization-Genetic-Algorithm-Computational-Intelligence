# -*- coding: utf-8 -*-
"""GA,FAZZY

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SpDND7fEjRPz25-MZ5ua1hGAQNENQ3E9

install this library for Fuzzification process
"""

!pip install scikit-fuzzy

"""fuzzy of The daily available man hours for the chassis assembly line is 1800 with Trapezoidal Membership Function"""

import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl
import matplotlib.pyplot as plt

# Universe of discourse for Chassis Assembly Hours
Chassis_Assembly_Hours = np.arange(0, 2100, 1)  # range values from 0 to 2100

# Fuzzy variable for Chassis Assembly Hours
assembly_hours_fuzzy = ctrl.Antecedent(Chassis_Assembly_Hours, 'Chassis_Assembly_Hours')

# Membership functions for Chassis Assembly Hours using trapezoidal membership functions
assembly_hours_fuzzy['low'] = fuzz.trapmf(assembly_hours_fuzzy.universe, [0, 0, 600, 1000])
assembly_hours_fuzzy['medium'] = fuzz.trapmf(assembly_hours_fuzzy.universe, [800, 1000, 1400, 1600])
assembly_hours_fuzzy['high'] = fuzz.trapmf(assembly_hours_fuzzy.universe, [1400, 1600, 2000, 2000])

# Visualize these membership functions
assembly_hours_fuzzy.view()
#show the plot
plt.show()

"""one example of change from Crisp value to fuzzy."""

crisp_Chassis_Assembly_Hours = 1750
# Fuzzify the crisp Chassis_Assembly_Hours
fuzzy_value_low = fuzz.interp_membership(assembly_hours_fuzzy.universe,assembly_hours_fuzzy['low'].mf, crisp_Chassis_Assembly_Hours)
fuzzy_value_medium = fuzz.interp_membership(assembly_hours_fuzzy.universe, assembly_hours_fuzzy['medium'].mf, crisp_Chassis_Assembly_Hours)
fuzzy_value_high = fuzz.interp_membership(assembly_hours_fuzzy.universe, assembly_hours_fuzzy['high'].mf, crisp_Chassis_Assembly_Hours)

print(f"Fuzzy value for 'low' at {crisp_Chassis_Assembly_Hours}: {fuzzy_value_low}")
print(f"Fuzzy value for 'medium' at {crisp_Chassis_Assembly_Hours}: {fuzzy_value_medium}")
print(f"Fuzzy value for 'high' at {crisp_Chassis_Assembly_Hours}: {fuzzy_value_high}")

assembly_hours_fuzzy['medium'].mf[1250]

"""code of defuzzification process"""

# Simulate 'defuzzified' demand using Monte Carlo simulation
num_simulations = 4
defuzzified_Chassis_Assembly_Hours = []

for i in range(num_simulations):
    print("Iteration number:",i+1,"/{}.".format(num_simulations))
    print("----------------------------")
    print("----------------------------")
    while True:
        x = np.random.uniform(0, 1800)  # Random x within [0, 1800]
        u = fuzz.interp_membership(assembly_hours_fuzzy.universe, assembly_hours_fuzzy['high'].mf, x)
        alpha = np.random.uniform(0, 1)
        print("x=",x,"u=",u,"alpha=",alpha)
        print("---------")
        if alpha <= u:
            defuzzified_Chassis_Assembly_Hours.append(x)
            break

defuzzified_Chassis_Assembly_Hours

"""Average 'defuzzified' demand over x simulations:"""

# Calculate the average 'defuzzified' demand
average_defuzzified_Chassis_Assembly_Hours = np.mean(defuzzified_Chassis_Assembly_Hours)
avg1=average_defuzzified_Chassis_Assembly_Hours
print(f"Average 'defuzzified' demand over {num_simulations} simulations: {avg1:.2f}")

"""fuzzy of The daily available production line hours = 240"""

# Universe of discourse for production line hours
production_line_hours = np.arange(0, 300, 1)  # range values from 0 to 300

# Fuzzy variable for production line hours
production_line_hours_fuzzy = ctrl.Antecedent(production_line_hours, 'production_line_hours')

# Define membership functions
low_mf = fuzz.trimf(production_line_hours_fuzzy.universe, [0, 80, 120])
medium_mf = fuzz.trimf(production_line_hours_fuzzy.universe, [100, 160, 200])
high_mf = fuzz.trimf(production_line_hours_fuzzy.universe, [180, 240, 300])

# Assign membership functions
production_line_hours_fuzzy['low'] = low_mf
production_line_hours_fuzzy['medium'] = medium_mf
production_line_hours_fuzzy['high'] = high_mf

"""graph of 3 membership"""

# Visualize the membership functions
production_line_hours_fuzzy.view()
#show the plot
plt.show()

"""one example of change from Crisp value to fuzzy."""

crisp_production_line_hours= 110
# Fuzzify the crisp production_line_hours
fuzzy_value_low = fuzz.interp_membership(production_line_hours_fuzzy.universe, low_mf, crisp_production_line_hours)
fuzzy_value_medium = fuzz.interp_membership(production_line_hours_fuzzy.universe, medium_mf, crisp_production_line_hours)
fuzzy_value_high = fuzz.interp_membership(production_line_hours_fuzzy.universe,  high_mf, crisp_production_line_hours)

print(f"Fuzzy value for 'low' at {crisp_production_line_hours}: {fuzzy_value_low}")
print(f"Fuzzy value for 'medium' at {crisp_production_line_hours}: {fuzzy_value_medium}")
print(f"Fuzzy value for 'high' at {crisp_production_line_hours}: {fuzzy_value_high}")

"""code of defuzzification process"""

# Simulate 'defuzzified' demand using Monte Carlo simulation
num_simulations = 4
defuzzified_production_line_hours = []

for i in range(num_simulations):
    print("Iteration number:",i+1,"/{}.".format(num_simulations))
    print("----------------------------")
    print("----------------------------")
    while True:
        x = np.random.uniform(0, 240)  # Random x within [0, 240]
        u = fuzz.interp_membership(production_line_hours_fuzzy.universe, production_line_hours_fuzzy['medium'].mf, x)
        alpha = np.random.uniform(0, 1)
        print("x=",x,"u=",u,"alpha=",alpha)
        print("---------")
        if alpha <= u:
            defuzzified_production_line_hours.append(x)
            break

defuzzified_production_line_hours

"""Average 'defuzzified' demand over x simulations:"""

# Calculate the average 'defuzzified' demand
average_defuzzified_production_line_hours = np.mean(defuzzified_production_line_hours)
avg2=average_defuzzified_production_line_hours
print(f"Average 'defuzzified' demand over {num_simulations} simulations: {avg2:.2f}")

import random
import math
class ManufacturingGA:
    def __init__(self, pop_size: int, R_max: int, R_min: int, crossover_prob: float, mutation_prob: float):
        """
        Initialize the genetic algorithm parameters.
        """
        self.pop_size = pop_size
        self.R_max = R_max
        self.R_min = R_min
        self.crossover_prob = crossover_prob
        self.mutation_prob = mutation_prob

    def initialize_population(self):
        """
        Initialize the population with random individuals.
        """
        return [[random.randint(self.R_min, self.R_max) for _ in range(2)] for _ in range(self.pop_size)]

    def evaluate_fitness(self, individual):
        """
        Evaluate the fitness of an individual solution.
        """

        x1, x2 = individual
        profit_bw = 150 * x1
        profit_colored = 450 * x2
        return profit_bw + profit_colored

    def linear_rank_selection(self, pop, sp):
        """
        Perform linear rank selection to assign probabilities to individuals.
        """
        pop_size = len(pop)
        pop_fitness = [self.evaluate_fitness(indv) for indv in pop]
        ranks = np.array(pop_fitness).argsort().argsort() + 1
        pop_linear_rank_fitness = [(2 - sp) + 2 * (sp - 1) * (rank - 1) / (pop_size - 1) for rank in ranks]

        # Normalize probabilities
        total_prob = sum(pop_linear_rank_fitness)
        normalized_probabilities = [prob / total_prob for prob in pop_linear_rank_fitness]
        return normalized_probabilities

    def select_parents(self, pop, pop_fitness):
        """
        Select parents based on cumulative probabilities.
        """
        cumulative_probabilities = np.cumsum(self.linear_rank_selection(pop, sp))
        selected_parents = random.choices(pop, cum_weights=cumulative_probabilities, k=2)
        return selected_parents

    def crossover(self, parents):
        """
        Perform crossover between two parents.
        """
        if random.random() < self.crossover_prob:
            crossover_point = random.randint(1, len(parents[0]) - 1)
            offspring1 = parents[0][:crossover_point] + parents[1][crossover_point:]
            offspring2 = parents[1][:crossover_point] + parents[0][crossover_point:]
            return [offspring1, offspring2]
        else:
            return parents

    def mutate(self, individual):
        """
        Perform mutation on an individual.
        """
        mutated_individual = [bit ^ 1 if random.random() < self.mutation_prob else bit for bit in individual]
        return mutated_individual

    def constraints_satisfied(self, individual):
        x1 , x2 = individual
        # Check constraints
        if x2 > 50:
            return False
        #using Average 'defuzzified' demand over 4 simulations insteade of main values of problem
        if (6*x1 + 18*x2) > avg1:
            return False
        if (x1 + 1.6*x2) > avg2:
            return False
        if (0.5*x1 + 2*x2) > 162:
            return False
        return True

    def solve(self, max_generations: int, sp: float):
        # Initialization
        self.population = self.initialize_population()

        for generation in range(max_generations):
            pop_fitness = [self.evaluate_fitness(indv) for indv in self.population]

            # Parent selection
            selected_parents = [self.select_parents(self.population, pop_fitness) for _ in range(self.pop_size // 2)]

            # Crossover
            offspring = [child for parent_pair in selected_parents for child in self.crossover(parent_pair)]

            # Mutation
            mutated_offspring = [self.mutate(child) for child in offspring]

            # Ensure constraints are satisfied
            mutated_offspring = [child for child in mutated_offspring if self.constraints_satisfied(child)]

            # Combine parents and mutated offspring
            combined_pop = self.population + mutated_offspring

            # Select the next generation
            next_gen_indices = np.random.choice(len(combined_pop), size=self.pop_size, p=self.linear_rank_selection(combined_pop, sp))
            self.population = [combined_pop[i] for i in next_gen_indices]

        best_solution = max(self.population, key=self.evaluate_fitness)
        return best_solution


if __name__ == "__main__":
    pop_size = 100
    R_max = 50  # Maximum number of TV sets (colored)
    R_min = 0   # Minimum number of TV sets
    crossover_prob = 0.6
    mutation_prob = 0.05
    max_generations = 100
    sp = 1.5  # Selection pressure

    manufacturing_ga = ManufacturingGA(pop_size, R_max, R_min, crossover_prob, mutation_prob)
    best_solution = manufacturing_ga.solve(max_generations, sp)

    print("Best solution:", best_solution)
    print("Fitness:", manufacturing_ga.evaluate_fitness(best_solution))